<!DOCTYPE html>
<html>
	<canvas id = 'c' width = '400' height = '400' style="border:1px solid #000000;"></canvas>
	<script src = 'webgl-utils.js'></script> <!-- USES THE UTILS DEFINED -->
	<script id = 'vshader' type = 'x-shader'>
		attribute vec2 aVertexPosition; //Atributes are passed per vertex data
		attribute vec3 aColorPosition;
		varying vec2 vTexCoord; //value that will pass to the fragment shader. In this case, the texture coordenate
		varying vec3 Color;
		void main(){
			vTexCoord = aVertexPosition;
			Color = aColorPosition;
			gl_Position = vec4(aVertexPosition, 0, 1);
		}
	</script>
	<script id = 'fshader' type = 'x-shader'>
		precision mediump float;
		varying vec2 vTexCoord; //get the passing value from the vertex shader
		varying vec3 Color;
		
		void main(){

			gl_FragColor = vec4(Color, 1);

			if ((vTexCoord.x) * (vTexCoord.x) + (vTexCoord.y) * (vTexCoord.y) >= 1.0){
				gl_FragColor = vec4(0, 1, 1, 0);
			}	
		}
	</script>
	<script>



	var angles = [100, 50, 20, 100];
	var currentCoordinate = [0,1];
	var sumAngles = 0;
	var coordinates = [];
	var xCoord;
	var yCoord;

	for(i in angles){
		if (sumAngles <= 90){
			if (i <= 90) sumAngles += i;
			else sumAngles += 90;

			if  (sumAngles < 60){
				yCoord = 1;
				xCoord = Math.tan(i)*yCoord;
				coordinates.push([xCoord, yCoord]);
			} 
			else{
				xCoord = 1;
				yCoord = Math.tan(i)*yCoord;
				coordinates.push([xCoord, yCoord]);
			}

		}
	}

	console.log(coordinates);




	var c = document.getElementById('c');
	var gl = c.getContext('experimental-webgl');

	//Define VERTEX SHADER and FRAGMENT SHADER
	vs = document.getElementById('vshader').textContent;
	fs = document.getElementById('fshader').textContent;


	var program = createProgram(vs,fs);
	gl.useProgram(program);

	program.vertexPosAttrib = gl.getAttribLocation(program, 'aVertexPosition');
	program.colorAttrib = gl.getAttribLocation(program, 'aColorPosition');
	console.log(program.vertexPosAttrib);
	console.log(program.colorAttrib);
	gl.enableVertexAttribArray(program.vertexPosAttrib);
	gl.enableVertexAttribArray(program.colorAttrib);


	//To create some geometry we need some BUFFER to hold some VERTEX data
	var vertexPosBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer); //Bind buffer to the Bind point named ARRAY_BUFFER
	var vertices = [-1, -1 , 1, -1, -1, 1 , 1, 1, 0, 0, 0, 1, 1, 0, 1, 1] //coordenates range from -1 to 1. So this will cover all the canvas

	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW); //FLOAT32ARRAY is what we need to pass to the buffer. STATIC_DRAW means that we upload the data 
																				//once and draw it several times
	vertexPosBuffer.itemSize = 2; //Atributes for the buffer. SIze and number of items
	vertexPosBuffer.numItems = 8;
	gl.vertexAttribPointer(program.vertexPosAttrib, vertexPosBuffer.itemSize , gl.FLOAT, false , 0, 0); //Set the format of the IN data. 2 component, float and dont nedd to be normalized

	var colors = [
		0, 0 , 1,
		0, 0 , 1,
		0, 0 , 1,
		0, 0 , 1,
		1, 0 , 0,
		1, 0 , 0,
		1, 0 , 0,
		1, 0 , 0
	];

	var colorElements = []

	var colorBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
	
	colorBuffer.itemSize = 3; //Atributes for the buffer. SIze and number of items
	colorBuffer.numItems = 8;

	gl.vertexAttribPointer(program.colorAttrib, colorBuffer.itemSize , gl.FLOAT, false , 0, 0);
	/*
	 2___ 3 
	 |\  |		//Square is defined in this case as a triangle strip, two triangles combined
	 | \ | 
	0|__\|1
	*/

	gl.drawArrays(gl.TRIANGLE_STRIP, 0 , vertexPosBuffer.numItems); //Now takes 4 vertex instead of 3 like the triangle

	</script>


</html>