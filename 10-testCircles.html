<!DOCTYPE html>
<html>
	<canvas id = 'c' width = '400' height = '400' style="border:1px solid #000000;"></canvas>
	<script src = 'webgl-utils.js'></script> <!-- USES THE UTILS DEFINED -->
	<script id = 'vshader' type = 'x-shader'>
		attribute vec2 aVertexPosition; //Atributes are passed per vertex data
		varying vec2 vTexCoord; //value that will pass to the fragment shader. In this case, the texture coordenate
		void main(){
			vTexCoord = aVertexPosition;
			gl_Position = vec4(aVertexPosition, 0, 1);
		}
	</script>
	<script id = 'fshader' type = 'x-shader'>
		precision mediump float;
		varying vec2 vTexCoord; //get the passing value from the vertex shader
		uniform int unumberOfParts;
		void main(){

			vec4 angles = vec4(100.0, 110.0, 70.0, 30.0);
			float prevAngle = radians(0.0);
			float radQuad = radians(90.0);
			float totalAngles = 0.0;

			bool found = false;
			bool hasRest = false;
			float rad = 0.0;
			float AngleToUse = 0.0;
			float rest;

			 if (vTexCoord.y < 0.0 && vTexCoord.x < 0.0){
			 	for (int i = 0; i<4;i++){
			 		totalAngles = totalAngles + angles[i];
			 		if (totalAngles > 90.0){
			 			rest = totalAngles - 90.0;
			 			AngleToUse = angles[i] - rest;
			 			hasRest = true;
			 		}
			 		else{
			 			AngleToUse = angles[i];
			 		}
			 		rad = radians(AngleToUse);
			 		if ((tan(rad + prevAngle) >= (vTexCoord.y) / (vTexCoord.x)) && (tan(prevAngle) <= (vTexCoord.y) / (vTexCoord.x))){
			 			float color = float(i) * 0.3;
			 			if ((vTexCoord.x) * (vTexCoord.x) + (vTexCoord.y) * (vTexCoord.y) < 1.0){
			 				//gl_FragColor = vec4(1, 0, 0, 1);
								 	
			 					 		gl_FragColor = vec4(color, 0, 0, 1);
								 		found = true;

			 			}	
			 		}
			 		prevAngle = prevAngle + rad;
			 		if (totalAngles > 90.0){
			 			break;
			 		}
			 	}
			}

			else{
			 	if (vTexCoord.y < 0.0 && vTexCoord.x > 0.0){
			 		for (int i = 0; i<4;i++){
				 		totalAngles = totalAngles + angles[i];
				 		if (totalAngles >= 90.0){
				 			if (totalAngles - angles[i] < 90.0){
				 				AngleToUse = totalAngles - 90.0;
				 			}
				 			else if (totalAngles > 180.0){
				 				rest = totalAngles - 180.0;
				 				AngleToUse = angles[i] - rest;
				 				hasRest = true;
				 			}
				 			else{
				 				AngleToUse = angles[i];
				 			}

				 			rad = radians(AngleToUse);
				 		 	if ((tan(radQuad - (rad + prevAngle)) <= (vTexCoord.y) / -(vTexCoord.x)) && (tan(radQuad - (prevAngle)) >= (vTexCoord.y) / -(vTexCoord.x))){
				 		 	 	float color = float(i) * 0.3;
				 		 	 	//if ((vTexCoord.x) * (vTexCoord.x) + (vTexCoord.y) * (vTexCoord.y) < 1.0){
				 		 	 		//gl_FragColor = vec4(1, 0, 0, 1);
										 	
				 		 	 			 		//gl_FragColor = vec4(1, 0, 0, 1);
				 		 	 			 		found = true;

				 		 	 	//}	
				 		 	 }
				 		 	 prevAngle = prevAngle + rad;
				 		 	 if (totalAngles > 180.0){
				 				break;
				 			 }

				 		} 
				 	}
				 }
			 } 

			//  else if (vTexCoord.y > 0.0 && vTexCoord.x > 0.0){
			//   	for (int i = 0; i<4;i++){
			//   		totalAngles = totalAngles + angles[i];
			//   		if (totalAngles >= 180.0){
			//   			if (totalAngles - angles[i] < 180.0){
			//   				AngleToUse = totalAngles - 180.0;
			//   			}
			//   			else if (totalAngles > 270.0){
			// 				rest = totalAngles - 270.0;
			// 				AngleToUse = angles[i] - rest;
			// 				hasRest = true;
			// 			}
			//   			else{
			//   				AngleToUse = angles[i];
			//   			}

			//   			rad = radians(AngleToUse);
			//   		 	if ((tan(rad + prevAngle) >= (vTexCoord.y) / (vTexCoord.x)) && (tan(prevAngle) <= (vTexCoord.y) / (vTexCoord.x))){
			//  				float color = float(i) * 0.3;
			//  				if ((vTexCoord.x) * (vTexCoord.x) + (vTexCoord.y) * (vTexCoord.y) < 1.0){
			//  					//gl_FragColor = vec4(1, 0, 0, 1);
									 	
			//  						 		gl_FragColor = vec4(color, 0, 0, 1);
			//  						 		found = true;

			//  				}	
			//  			}
			//   		 	 prevAngle = prevAngle + rad;
			//   		 	 if (totalAngles > 270.0){
			// 				break;
			// 			 }

			//   		} 
			//   	}
			//   }

			//   else if (vTexCoord.y > 0.0 && vTexCoord.x < 0.0){
			//  	for (int i = 0; i<4;i++){
			//  		totalAngles = totalAngles + angles[i];
			//  		if (totalAngles >= 270.0){
			//  			if (totalAngles - angles[i] < 270.0){
			//  				AngleToUse = totalAngles - 270.0;
			//  			}
			//  			else{
			//  				AngleToUse = angles[i];
			//  			}

			//  			rad = radians(AngleToUse);
			//  		 	 if ((tan((rad + prevAngle)) >= -(vTexCoord.x) / (vTexCoord.y)) && (tan((prevAngle)) <= -(vTexCoord.x) / (vTexCoord.y))){
			//  		 	 	float color = float(i) * 0.3;
			//  		 	 	if ((vTexCoord.x) * (vTexCoord.x) + (vTexCoord.y) * (vTexCoord.y) < 1.0){
			//  		 	 		//gl_FragColor = vec4(1, 0, 0, 1);
									 	
			//  		 	 			 		gl_FragColor = vec4(color, 0, 0, 1);
			//  		 	 			 		found = true;

			//  		 	 	}	
			//  		 	 }
			//  		 	 prevAngle = prevAngle + rad;
			//  		 	 if (totalAngles > 360.0){
			//  				break;
			//  			 }

			//  		} 
			//  	}
			//  }

			
		
		if (found == false){
			if ((vTexCoord.x) * (vTexCoord.x) + (vTexCoord.y) * (vTexCoord.y) < 1.0){
				gl_FragColor = vec4(0, 0, 1, 1);
			}
		}
			
		}
	</script>
	<script>

	var c = document.getElementById('c');
	var gl = c.getContext('experimental-webgl');

	//To create some geometry we need some BUFFER to hold some VERTEX data
	var vertexPosBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer); //Bind buffer to the Bind point named ARRAY_BUFFER
	var vertices = [-1, -1 , 1, -1, -1, 1 , 1, 1] //coordenates range from -1 to 1. So this will cover all the canvas
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW); //FLOAT32ARRAY is what we need to pass to the buffer. STATIC_DRAW means that we upload the data 
																				//once and draw it several times
	vertexPosBuffer.itemSize = 2; //Atributes for the buffer. SIze and number of items
	vertexPosBuffer.numItems = 4;
	vertexPosBuffer.numberOfParts = 2;
	/*
	 2___ 3 
	 |\  |		//Square is defined in this case as a triangle strip, two triangles combined
	 | \ | 
	0|__\|1
	*/

	//Define VERTEX SHADER and FRAGMENT SHADER
	vs = document.getElementById('vshader').textContent;
	fs = document.getElementById('fshader').textContent;

	console.log(vs);
	console.log(fs);


	var program = createProgram(vs,fs);
	gl.useProgram(program);
	program.vertexPosAttrib = gl.getAttribLocation(program,'aVertexPosition');
	program.numberOfParts = gl.getUniformLocation(program,'anumberOfParts');
	gl.enableVertexAttribArray(program.vertexPosArray);
	gl.vertexAttribPointer(program.vertexPosAttrib, vertexPosBuffer.itemSize , gl.FLOAT, false , 0, 0); //Set the format of the IN data. 2 component, float and dont nedd to be normalized
	console.log(vertexPosBuffer.numberOfParts);
	gl.uniform1i(program.numberOfParts, vertexPosBuffer.numberOfParts);
	//gl.uniform2f(program.offsetUniform, offset[0], offset[1]); //passing the values to the location of the uniform inside the program
	gl.drawArrays(gl.TRIANGLE_STRIP, 0 , vertexPosBuffer.numItems); //Now takes 4 vertex instead of 3 like the triangle

	</script>


</html>